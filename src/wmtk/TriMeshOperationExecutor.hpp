#pragma once
#include <wmtk/utils/Logger.hpp>
#include "SimplicialComplex.hpp"
#include "TriMesh.hpp"
#include "Tuple.hpp"
namespace wmtk {
class TriMesh::TriMeshOperationExecutor
{
public:
    TriMeshOperationExecutor(TriMesh& m, const Tuple& operating_tuple);
    void delete_simplices();
    void update_cell_hash();

    std::array<Accessor<char>, 3> flag_accessors;
    Accessor<long> ff_accessor;
    Accessor<long> fe_accessor;
    Accessor<long> fv_accessor;
    Accessor<long> vf_accessor;
    Accessor<long> ef_accessor;
    Accessor<long> hash_accessor;


    //           C
    //         /  \ .
    //    F1  /    \  F2
    //       /      \ .
    //      /        \ .
    //     A----------B
    //      \        /
    //       \      /
    //    F1' \    / F2'
    //         \  /
    //          C'
    // the neighbors are stored in the order of A, B, C, D if they exist
    // vid, ear fid (-1 if it doesn't exit), ear eid

    /**
     * An ear is a face that is adjacent to a face that is incident to the edge on which the
     * operation is performed. In other words, the ears are the neighboring faces to the ones that
     * will be deleted by the operation.
     */
    struct EarFace
    {
        long fid = -1; // global fid of the ear, -1 if it doesn't exist
        long eid = -1; // global eid of the ear, -1 if it doesn't exist
    };

    /**
     * Data on the incident face relevant for performing operations.
     */
    struct IncidentFaceData
    {
        long opposite_vid = -1; // opposing vid
        long fid = -1; // the face that will be deleted
        std::array<EarFace, 2> ears; // ear
    };

    const std::vector<IncidentFaceData>& incident_face_datas() const
    {
        return m_incident_face_datas;
    }

    const std::array<long, 2>& incident_vids() const { return m_incident_vids; }

    const long operating_edge_id() const { return m_operating_edge_id; }

    void glue_ear_to_face(
        const long ear_fid,
        const long new_face_fid,
        const long old_fid,
        const long eid);

    void merge(const long& new_vid);
    Tuple split_edge();

    /**
     * @brief
     *
     * @param new_fids_top the two new fids on the top sides of AB generated by split_edge(AB)
     * @param new_fids_bottom the two new fids on the bottom sides of AB generated by split_edge(AB)
     */
    // return the two new fids in order
    std::array<long, 2> glue_new_triangle_topology(
        const long new_vid,
        const std::vector<long>& replacement_eids,
        const IncidentFaceData& face_data);
    void glue_new_faces_across_AB(
        const std::array<long, 2> new_fids_top,
        const std::array<long, 2> new_fids_bottom);
    std::vector<long> request_simplex_indices(const PrimitiveType type, long count);

    std::vector<std::vector<long>> simplices_to_delete; // size 3 for vertex, edge, face
    std::vector<long> cells_to_update_hash;
    TriMesh& m_mesh;
    Tuple m_operating_tuple;

private:
    // common simplicies
    std::array<long, 2> m_incident_vids; // V_A_id, V_B_id;
    long m_operating_edge_id;

    // simplices required per-face
    std::vector<IncidentFaceData> m_incident_face_datas;

    IncidentFaceData get_incident_face_data(const Tuple& t);
};
} // namespace wmtk
