#include "TriMesh.hpp"

#include <wmtk/utils/trimesh_topology_initialization.h>
#include <wmtk/autogen/autogenerated_2d_tables.hpp>
#include <wmtk/utils/Logger.hpp>

namespace wmtk {
TriMesh::TriMesh()
    : Mesh(3)
    , m_vf_handle(register_attribute<long>("m_vf", PrimitiveType::Vertex, 1))
    , m_ef_handle(register_attribute<long>("m_ef", PrimitiveType::Edge, 1))
    , m_fv_handle(register_attribute<long>("m_fv", PrimitiveType::Face, 3))
    , m_fe_handle(register_attribute<long>("m_fe", PrimitiveType::Face, 3))
    , m_ff_handle(register_attribute<long>("m_ff", PrimitiveType::Face, 3))
{}

void TriMesh::split_edge(const Tuple& t) {}
void TriMesh::collapse_edge(const Tuple& t) {}

long TriMesh::id(const Tuple& tuple, const PrimitiveType& type) const
{
    switch (type) {
    case PrimitiveType::Vertex: {
        ConstAccessor<long> fv_accessor = create_accessor<long>(m_fv_handle);
        auto fv = fv_accessor.vector_attribute(tuple);
        return fv(tuple.m_local_vid);
        break;
    }
    case PrimitiveType::Edge: {
        ConstAccessor<long> fe_accessor = create_accessor<long>(m_fe_handle);
        auto fe = fe_accessor.vector_attribute(tuple);
        return fe(tuple.m_local_eid);
        break;
    }
    case PrimitiveType::Face: {
        return tuple.m_global_cid;
        break;
    }
    default: throw std::runtime_error("Tuple id: Invalid primitive type");
    }
}
bool TriMesh::is_boundary(const Tuple& tuple) const
{
    ConstAccessor<long> ff_accessor = create_accessor<long>(m_ff_handle);
    return ff_accessor.scalar_attribute(tuple) < 0;
}
Tuple TriMesh::switch_tuple(const Tuple& tuple, const PrimitiveType& type) const
{
    bool ccw = is_ccw(tuple);
    int offset = (tuple.m_local_vid * 3 + tuple.m_local_eid);

    switch (type) {
    case PrimitiveType::Vertex:
        return Tuple(
            wmtk::autogen::auto_2d_table_vertex[offset][0],
            wmtk::autogen::auto_2d_table_vertex[offset][1],
            tuple.m_local_fid,
            tuple.m_global_cid,
            tuple.m_hash);

    case PrimitiveType::Edge:
        return Tuple(
            wmtk::autogen::auto_2d_table_edge[offset][0],
            wmtk::autogen::auto_2d_table_edge[offset][1],
            tuple.m_local_fid,
            tuple.m_global_cid,
            tuple.m_hash);
    case PrimitiveType::Face: {
        long gvid = id(tuple, PrimitiveType::Vertex);
        long geid = id(tuple, PrimitiveType::Edge);
        ConstAccessor<long> ff_accessor = create_accessor<long>(m_ff_handle);
        auto ff = ff_accessor.vector_attribute(tuple);
        long gcid_new = ff(tuple.m_local_eid);
        long lvid_new, leid_new;
        ConstAccessor<long> fv_accessor = create_accessor<long>(m_fv_handle);
        auto fv = fv_accessor.vector_attribute(gcid_new);
        ConstAccessor<long> fe_accessor = create_accessor<long>(m_fe_handle);
        auto fe = fe_accessor.vector_attribute(gcid_new);
        for (long i = 0; i < 3; ++i) {
            if (fe(i) == geid) {
                leid_new = fe(i);
            }
            if (fv(i) == gvid) {
                lvid_new = fv(i);
            }
        }
        return Tuple(lvid_new, leid_new, tuple.m_local_fid, gcid_new, tuple.m_hash);
    }
    default: throw std::runtime_error("Tuple switch: Invalid primitive type"); break;
    }
}

bool TriMesh::is_ccw(const Tuple& tuple) const
{
    ConstAccessor<long> fv_accessor = create_accessor<long>(m_fv_handle);
    auto fv = fv_accessor.vector_attribute(tuple);
    if (fv((tuple.m_local_eid + 1) % 3) == id(tuple, PrimitiveType::Vertex))
        return true;
    else
        return false;
}

void TriMesh::initialize(
    Eigen::Ref<const RowVectors3l> FV,
    Eigen::Ref<const RowVectors3l> FE,
    Eigen::Ref<const RowVectors3l> FF,
    Eigen::Ref<const VectorXl> VF,
    Eigen::Ref<const VectorXl> EF)
{
    // reserve memory for attributes


    std::vector<long> cap{
        static_cast<long>(VF.rows()),
        static_cast<long>(EF.rows()),
        static_cast<long>(FF.rows())};

    set_capacities(cap);
    reserve_attributes_to_fit();

    // get Accessors for topology
    Accessor<long> fv_accessor = create_accessor<long>(m_fv_handle);
    Accessor<long> fe_accessor = create_accessor<long>(m_fe_handle);
    Accessor<long> ff_accessor = create_accessor<long>(m_ff_handle);
    Accessor<long> vf_accessor = create_accessor<long>(m_vf_handle);
    Accessor<long> ef_accessor = create_accessor<long>(m_ef_handle);
    // iterate over the matrices and fill attributes
    for (long i = 0; i < capacity(PrimitiveType::Face); ++i) {
        fv_accessor.vector_attribute(i) = FV.row(i).transpose();
        fe_accessor.vector_attribute(i) = FE.row(i).transpose();
        ff_accessor.vector_attribute(i) = FF.row(i).transpose();
    }
    // m_vf
    for (long i = 0; i < capacity(PrimitiveType::Vertex); ++i) {
        vf_accessor.scalar_attribute(i) = VF(i);
    }
    // m_ef
    for (long i = 0; i < capacity(PrimitiveType::Edge); ++i) {
        ef_accessor.scalar_attribute(i) = EF(i);
    }
}

void TriMesh::initialize(Eigen::Ref<const RowVectors3l> F)
{
    auto [FE, FF, VF, EF] = trimesh_topology_initialization(F);
    initialize(F, FE, FF, VF, EF);
}

std::vector<Tuple> TriMesh::get_all(const PrimitiveType& type) const
{
    ConstAccessor<char> flag_accessor = get_flag_accessor(type);
    std::vector<Tuple> ret;
    long cap = capacity(type);
    ret.reserve(cap);
    for (size_t index = 0; index < cap; ++index) {
        if (!(flag_accessor.scalar_attribute(index) & 1)) {
            ret.emplace_back(tuple_from_id(type, index));
        }
    }
    return ret;
}

long TriMesh::_debug_id(const Tuple& tuple, const PrimitiveType& type) const
{
    // do not remove this warning!
    wmtk::logger().warn("This function must only be used for debugging!!");
    return id(tuple, type);
}

Tuple TriMesh::tuple_from_id(const PrimitiveType type, const long gid) const
{
    switch (type) {
    case PrimitiveType::Vertex: {
        return vertex_tuple_from_id(gid);
        break;
    }
    case PrimitiveType::Edge: {
        return edge_tuple_from_id(gid);
        break;
    }
    case PrimitiveType::Face: {
        return face_tuple_from_id(gid);
        break;
    }
    case PrimitiveType::Tetrahedron: {
        throw std::runtime_error("no tet tuple supported for trimesh");
        break;
    }
    default: throw std::runtime_error("Invalid primitive type");
    }
}

Tuple TriMesh::vertex_tuple_from_id(long id) const
{
    ConstAccessor<long> vf_accessor = create_accessor<long>(m_vf_handle);
    auto f = vf_accessor.scalar_attribute(id);
    ConstAccessor<long> fv_accessor = create_accessor<long>(m_fv_handle);
    auto fv = fv_accessor.vector_attribute(f);
    for (long i = 0; i < 3; ++i) {
        if (fv(i) == id) {
            Tuple v_tuple = Tuple(i, (i + 2) % 3, -1, f, 0);
            assert(is_ccw(v_tuple));
            assert(is_valid(v_tuple));
            return v_tuple;
        }
    }
    throw std::runtime_error("vertex_tuple_from_id failed");
}

Tuple TriMesh::edge_tuple_from_id(long id) const
{
    ConstAccessor<long> ef_accessor = create_accessor<long>(m_ef_handle);
    auto f = ef_accessor.scalar_attribute(id);
    ConstAccessor<long> fe_accessor = create_accessor<long>(m_fe_handle);
    auto fe = fe_accessor.vector_attribute(f);
    for (long i = 0; i < 3; ++i) {
        if (fe(i) == id) {
            Tuple e_tuple = Tuple((i + 1) % 3, i, -1, f, 0);
            assert(is_ccw(e_tuple));
            assert(is_valid(e_tuple));
            return e_tuple;
        }
    }
    throw std::runtime_error("edge_tuple_from_id failed");
}
Tuple TriMesh::face_tuple_from_id(long id) const
{
    Tuple f_tuple = Tuple(0, 2, -1, id, 0);
    assert(is_ccw(f_tuple));
    assert(is_valid(f_tuple));
    return f_tuple;
}
// TODO
bool TriMesh::is_valid(const Tuple& tuple) const
{
    // condition 1: global cid stays in bound, and is not removed
    const long gid = tuple.m_global_cid;
    // condition 2: hash


    // Condition 3: local ids are consistent
    const int v = tuple.m_local_vid;
    switch (tuple.m_local_eid) {
    case 0:
        if (tuple.m_local_vid == 1 || tuple.m_local_vid == 2)
            return true;
        else
            return false;
    case 1:
        if (tuple.m_local_vid == 0 || tuple.m_local_vid == 2)
            return true;
        else
            return false;
    case 2:
        if (tuple.m_local_vid == 1 || tuple.m_local_vid == 0)
            return true;
        else
            return false;
    default: throw std::runtime_error("tuple invlid failed local ids check");
    }
}
} // namespace wmtk
