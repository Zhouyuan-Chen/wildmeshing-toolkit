#include "TetEdgeSwap.hpp"
#include <wmtk/simplex/utils/SimplexComparisons.hpp>

#include <wmtk/Mesh.hpp>

namespace wmtk::operations::composite {
TetEdgeSwap::TetEdgeSwap(Mesh& m, long collapse_index)
    : Operation(m)
    , m_split(m)
    , m_collapse(m)
    , m_collapse_index(collapse_index)
{}

std::vector<Simplex> TetEdgeSwap::execute(const Simplex& simplex)
{
    const auto split_simplicies = m_split(simplex);
    if (split_simplicies.empty()) return {};
    assert(split_simplicies.size() == 1);

    // aftert split
    const Tuple& split_ret = split_simplicies.front().tuple();
    assert(!mesh().is_boundary(split_ret));
    auto iter_tuple = split_ret;
    std::vector<Tuple> candidate_edge_tuples;
    while (true) {
        candidate_edge_tuples.push_back(mesh().switch_edge(iter_tuple));
        iter_tuple = mesh().switch_tetrahedron(mesh().switch_face(iter_tuple));
        if (iter_tuple == split_ret) {
            break;
        }
    }

    assert(m_collapse_index < candidate_edge_tuples.size());

    const auto collapse_simplicies =
        m_collapse(Simplex(m_collapse.primitive_type(), candidate_edge_tuples[m_collapse_index]));
    if (collapse_simplicies.empty()) return {};
    assert(collapse_simplicies.size() == 1);

    // get the new edges generated by swap.
    auto edges_generated_by_split =
        m_split.new_edge_tuples(); // this should already be sorted in single thread
    auto edges_deleted_by_collapse = m_collapse.deleted_edge_tuples();
    std::vector<Simplex> edges_generated_by_swap;

    // resurrect the tuples
    // compare and get the new edges generated by swap
    for (long i = 0; i < edges_generated_by_split.size(); ++i) {
        edges_generated_by_split[i] = resurrect_tuple(edges_generated_by_split[i]);
    }

    for (long i = 0; i < edges_deleted_by_collapse.size(); ++i) {
        edges_deleted_by_collapse[i] = resurrect_tuple(edges_deleted_by_collapse[i]);
    }

    // sort and get the difference; is it possible to use std::set_difference?
    std::sort(
        edges_generated_by_split.begin(),
        edges_generated_by_split.end()); // this should be already sorted, can be removed
    std::sort(edges_deleted_by_collapse.begin(), edges_deleted_by_collapse.end());

    auto is_tuple_equal = [&](const Tuple& a, const Tuple& b) {
        return simplex::utils::SimplexComparisons::equal(
            mesh(),
            simplex::Simplex::edge(a),
            simplex::Simplex::edge(b));
    };

    long i = 0;
    long j = 0;

    while (i < edges_generated_by_split.size() && j < edges_deleted_by_collapse.size()) {
        if (is_tuple_equal(edges_generated_by_split[i], edges_deleted_by_collapse[j])) {
            ++i;
            ++j;
        } else {
            edges_generated_by_swap.push_back(simplex::Simplex::edge(edges_generated_by_split[i]));
            ++i;
        }
    }

    while (i < edges_generated_by_split.size()) {
        edges_generated_by_swap.push_back(simplex::Simplex::edge(edges_generated_by_split[i]));
        ++i;
    }

    assert(
        edges_generated_by_swap.size() ==
        (edges_generated_by_split.size() - edges_deleted_by_collapse.size()));


    // const Tuple output_tuple = mesh().switch_edge(collapse_simplicies.front().tuple());

    // TODO: get all new edges and return them
    // return {simplex::Simplex::edge(output_tuple)};

    return edges_generated_by_swap;
}

std::vector<Simplex> TetEdgeSwap::unmodified_primitives(const Simplex& simplex) const
{
    return {simplex};
}

} // namespace wmtk::operations::composite