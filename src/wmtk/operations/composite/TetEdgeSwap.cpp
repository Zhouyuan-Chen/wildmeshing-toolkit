#include "TetEdgeSwap.hpp"

#include <wmtk/Mesh.hpp>

namespace wmtk::operations::composite {
TetEdgeSwap::TetEdgeSwap(Mesh& m, long collapse_index)
    : Operation(m)
    , m_split(m)
    , m_collapse(m)
    , m_collapse_index(collapse_index)
{}

std::vector<Simplex> TetEdgeSwap::execute(const Simplex& simplex)
{
    const auto split_simplicies = m_split(simplex);
    if (split_simplicies.empty()) return {};
    assert(split_simplicies.size() == 1);

    // aftert split
    const Tuple& split_ret = split_simplicies.front().tuple();
    assert(!mesh().is_boundary(split_ret));
    auto iter_tuple = split_ret;
    std::vector<Tuple> candidate_edge_tuples;
    while (true) {
        candidate_edge_tuples.push_back(mesh().switch_edge(iter_tuple));
        iter_tuple = mesh().switch_tetrahedron(mesh().switch_face(iter_tuple));
        if (iter_tuple == split_ret) {
            break;
        }
    }

    assert(m_collapse_index < candidate_edge_tuples.size());

    const auto collapse_simplicies =
        m_collapse(Simplex(m_collapse.primitive_type(), candidate_edge_tuples[m_collapse_index]));
    if (collapse_simplicies.empty()) return {};
    assert(collapse_simplicies.size() == 1);

    // get the new edges generated by swap.
    auto edges_generated_by_split =
        m_split.new_edge_tuples(); // this should already be sorted in single thread
    auto edges_deleted_by_collapse = m_collapse.deleted_edge_tuples();
    std::vector<Tuple> edges_generated_by_swap;

    // resurrect the tuples
    // compare and get the new edges generated by swap
    for (long i = 0; i < edges_generated_by_split.size(); ++i) {
        edges_generated_by_split[i] = resurrect_tuple(edges_generated_by_split[i]);
    }

    for (long i = 0; i < edges_deleted_by_collapse.size(); ++i) {
        edges_deleted_by_collapse[i] = resurrect_tuple(edges_deleted_by_collapse[i]);
    }

    // std::sort(edges_generated_by_split.begin(), edges_generated_by_split.end());
    std::sort(edges_deleted_by_collapse.begin(), edges_deleted_by_collapse.end());


    const Tuple output_tuple = mesh().switch_edge(collapse_simplicies.front().tuple());

    // TODO: get all new edges and return them
    return {simplex::Simplex::edge(output_tuple)};
}

std::vector<Simplex> TetEdgeSwap::unmodified_primitives(const Simplex& simplex) const
{
    return {simplex};
}

} // namespace wmtk::operations::composite