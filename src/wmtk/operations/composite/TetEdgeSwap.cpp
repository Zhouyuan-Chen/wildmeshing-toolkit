#include "TetEdgeSwap.hpp"
#include <wmtk/simplex/closed_star.hpp>
#include <wmtk/simplex/open_star.hpp>
#include <wmtk/simplex/utils/SimplexComparisons.hpp>


#include <wmtk/Mesh.hpp>

namespace wmtk::operations::composite {
TetEdgeSwap::TetEdgeSwap(Mesh& m, long collapse_index)
    : Operation(m)
    , m_split(m)
    , m_collapse(m)
    , m_collapse_index(collapse_index)
{}

std::vector<Simplex> TetEdgeSwap::execute(const Simplex& simplex)
{
    const auto split_simplicies = m_split(simplex);
    if (split_simplicies.empty()) return {};
    assert(split_simplicies.size() == 1);

    // after split
    const Tuple& split_ret = split_simplicies.front().tuple();
    assert(!mesh().is_boundary(split_ret));
    auto iter_tuple = split_ret;
    std::vector<Tuple> candidate_edge_tuples;
    while (true) {
        candidate_edge_tuples.push_back(mesh().switch_edge(iter_tuple));
        iter_tuple = mesh().switch_tetrahedron(mesh().switch_face(iter_tuple));
        if (iter_tuple == split_ret) {
            break;
        }
    }

    assert(m_collapse_index < candidate_edge_tuples.size());

    const Tuple& collapse_tuple = candidate_edge_tuples[m_collapse_index];


    // before collapse, compute the edges generated by split - edges deleted by collapse

    // auto edges_generated_by_split = m_split.new_edge_tuples();
    const auto split_tuple_open_star = simplex::open_star(mesh(), Simplex::vertex(split_ret));
    std::array<std::vector<Simplex>, 4> simplices_generated_by_split;
    for (const Simplex& s : split_tuple_open_star.simplex_vector()) {
        simplices_generated_by_split[get_primitive_type_id(s.primitive_type())].emplace_back(s);
    }

    const auto v_open_star = simplex::open_star(mesh(), Simplex::vertex(collapse_tuple));
    const auto e_closed_star = simplex::closed_star(mesh(), Simplex::edge(collapse_tuple));
    const auto sc = simplex::SimplexCollection::get_intersection(v_open_star, e_closed_star);
    std::vector<Tuple> edge_tuples_generated_by_swap;
    std::vector<Tuple> face_tuples_generated_by_swap;


    std::array<std::vector<Simplex>, 4> simplices_deleted_by_collapse;

    for (const Simplex& s : sc.simplex_vector()) {
        simplices_deleted_by_collapse[get_primitive_type_id(s.primitive_type())].emplace_back(s);
    }

    // check if #edge_generated_by_split > #edges_deleted_by_collapse, if not, return face instead
    assert(simplices_generated_by_split[1].size() >= simplices_deleted_by_collapse[1].size());

    bool able_to_return_edges = true;
    if (simplices_generated_by_split[1].size() == simplices_deleted_by_collapse[1].size())
        able_to_return_edges = false;


    std::vector<Simplex> edges_generated_by_swap;
    std::vector<Simplex> faces_generated_by_swap;

    // add compare lambda here
    auto comp_simplex = [&](const Simplex& s1, const Simplex& s2) {
        return simplex::utils::SimplexComparisons::less(mesh(), s1, s2);
    };

    if (able_to_return_edges) {
        // can use std::difference with sorted vector, worth?
        // for (const auto& e_split : simplices_generated_by_split[1]) {
        //     bool preserve_flag = true;
        //     for (const auto& e_collapse : simplices_deleted_by_collapse[1]) {
        //         if (simplex::utils::SimplexComparisons::equal(mesh(), e_split, e_collapse)) {
        //             preserve_flag = false;
        //             break;
        //         }
        //     }
        //     if (preserve_flag) {
        //         edge_tuples_generated_by_swap.push_back(e_split.tuple());
        //     }
        // }

        // add new codes here

        // std::vector<Simplex> edges_generated_by_swap;
        std::sort(
            simplices_generated_by_split[1].begin(),
            simplices_generated_by_split[1].end(),
            comp_simplex);
        std::sort(
            simplices_deleted_by_collapse[1].begin(),
            simplices_deleted_by_collapse[1].end(),
            comp_simplex);

        std::set_difference(
            simplices_generated_by_split[1].begin(),
            simplices_generated_by_split[1].end(),
            simplices_deleted_by_collapse[1].begin(),
            simplices_deleted_by_collapse[1].end(),
            std::back_inserter(edges_generated_by_swap),
            comp_simplex);

        std::transform(
            edges_generated_by_swap.begin(),
            edges_generated_by_swap.end(),
            std::back_inserter(edge_tuples_generated_by_swap),
            [](const Simplex& s) { return s.tuple(); });
        // end of new codes

        assert(
            edge_tuples_generated_by_swap.size() ==
            (simplices_generated_by_split[1].size() - simplices_deleted_by_collapse[1].size()));
    } else {
        // return face
        // auto faces_generated_by_split = m_split.new_face_tuples();
        assert(simplices_generated_by_split[2].size() >= simplices_deleted_by_collapse[2].size());

        // for (const auto& f_split : simplices_generated_by_split[2]) {
        //     bool preserve_flag = true;
        //     for (const auto& f_collapse : simplices_deleted_by_collapse[2]) {
        //         if (simplex::utils::SimplexComparisons::equal(mesh(), f_split, f_collapse)) {
        //             preserve_flag = false;
        //             break;
        //         }
        //     }
        //     if (preserve_flag) {
        //         face_tuples_generated_by_swap.push_back(f_split.tuple());
        //     }
        // }

        // std::vector<Simplex> faces_generated_by_swap;
        std::sort(
            simplices_generated_by_split[2].begin(),
            simplices_generated_by_split[2].end(),
            comp_simplex);
        std::sort(
            simplices_deleted_by_collapse[2].begin(),
            simplices_deleted_by_collapse[2].end(),
            comp_simplex);


        std::set_difference(
            simplices_generated_by_split[2].begin(),
            simplices_generated_by_split[2].end(),
            simplices_deleted_by_collapse[2].begin(),
            simplices_deleted_by_collapse[2].end(),
            std::back_inserter(faces_generated_by_swap),
            comp_simplex);

        std::transform(
            faces_generated_by_swap.begin(),
            faces_generated_by_swap.end(),
            std::back_inserter(face_tuples_generated_by_swap),
            [](const Simplex& s) { return s.tuple(); });

        assert(
            face_tuples_generated_by_swap.size() ==
            (simplices_generated_by_split[2].size() - simplices_deleted_by_collapse[2].size()));
    }


    // do collapse
    const auto collapse_simplicies =
        m_collapse(Simplex(m_collapse.primitive_type(), collapse_tuple));
    if (collapse_simplicies.empty()) return {};
    assert(collapse_simplicies.size() == 1);


    // resurrect the edge tuples
    // if (able_to_return_edges) {
    //     std::vector<Simplex> edges_generated_by_swap;
    //     for (long i = 0; i < edge_tuples_generated_by_swap.size(); ++i) {
    //         // edge_tuples_generated_by_swap[i] = resurrect_tuple(edge_tuples_generated_by_swap[i]);
    //         edges_generated_by_swap.emplace_back(
    //             Simplex::edge(resurrect_tuple(edge_tuples_generated_by_swap[i])));
    //     }

    //     return edges_generated_by_swap;
    // } else {
    //     std::vector<Simplex> faces_generated_by_swap;
    //     for (long i = 0; i < face_tuples_generated_by_swap.size(); ++i) {
    //         // face_tuples_generated_by_swap[i] = resurrect_tuple(face_tuples_generated_by_swap[i]);
    //         faces_generated_by_swap.emplace_back(
    //             Simplex::face(resurrect_tuple(face_tuples_generated_by_swap[i])));
    //     }

    //     return faces_generated_by_swap;
    // }

    if (able_to_return_edges) {
        for (long i = 0; i < edges_generated_by_swap.size(); ++i) {
            edges_generated_by_swap[i] =
                Simplex::edge(resurrect_tuple(edges_generated_by_swap[i].tuple()));
        }

        return edges_generated_by_swap;
    } else {
        for (long i = 0; i < faces_generated_by_swap.size(); ++i) {
            faces_generated_by_swap[i] =
                Simplex::edge(resurrect_tuple(faces_generated_by_swap[i].tuple()));
        }

        return faces_generated_by_swap;
    }
}

std::vector<Simplex> TetEdgeSwap::unmodified_primitives(const Simplex& simplex) const
{
    return {simplex};
}

} // namespace wmtk::operations::composite